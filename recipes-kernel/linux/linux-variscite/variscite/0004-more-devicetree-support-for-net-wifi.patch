From 84c5bbf5281716e50ae500dde4003f151ca8399f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andreas=20M=C3=BCller?= <schnitzeltony@googlemail.com>
Date: Thu, 13 Nov 2014 13:13:54 +0100
Subject: [PATCH 4/8] more devicetree support for net/wifi
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

taken from git://github.com/varigit/linux-2.6-imx.git branch imx_3.10.17_1.0.0_ga_beta_var2

Signed-off-by: Andreas MÃ¼ller <schnitzeltony@googlemail.com>
---
 drivers/net/wireless/ti/wlcore/sdio.c | 70 +++++++++++++++++++++++++++++---
 net/rfkill/rfkill-gpio.c              | 76 ++++++++++++++++++++++++++---------
 net/rfkill/rfkill-regulator.c         | 45 +++++++++++++++++++--
 3 files changed, 161 insertions(+), 30 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index 29ef249..53bbb28 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -30,7 +30,7 @@
 #include <linux/mmc/sdio_ids.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
-#include <linux/gpio.h>
+#include <linux/of_irq.h>
 #include <linux/wl12xx.h>
 #include <linux/pm_runtime.h>
 #include <linux/printk.h>
@@ -214,6 +214,43 @@ static struct wl1271_if_operations sdio_ops = {
 	.set_block_size = wl1271_sdio_set_block_size,
 };
 
+static struct wl12xx_platform_data *wlcore_get_pdata_from_of(struct device *dev)
+{
+	struct wl12xx_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+
+	if (!np) {
+		np = of_find_matching_node(NULL, dev->driver->of_match_table);
+		if (!np) {
+			dev_notice(dev, "device tree node not available\n");
+			pdata = ERR_PTR(-ENODEV);
+			goto out;
+		}
+	}
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "can't allocate platform data\n");
+		pdata = ERR_PTR(-ENODEV);
+		goto out;
+	}
+
+	pdata->irq = irq_of_parse_and_map(np, 0);
+	if (pdata->irq < 0) {
+		dev_err(dev, "can't get interrupt gpio from the device tree\n");
+		goto out_free;
+	}
+	pdata->board_ref_clock = WL12XX_REFCLOCK_38; /* 38.4 MHz */
+	goto out;
+
+out_free:
+	kfree(pdata);
+	pdata = ERR_PTR(-ENODEV);
+
+out:
+	return pdata;
+}
+
 static int wl1271_probe(struct sdio_func *func,
 				  const struct sdio_device_id *id)
 {
@@ -248,11 +285,23 @@ static int wl1271_probe(struct sdio_func *func,
 	/* Use block mode for transferring over one block size of data */
 	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
 
+	/* The pdata allocated here is freed when the device is freed,
+	 * so we don't need an additional out label to free it in case
+	 * of error further on.
+	 */
+
+	/* Try to get legacy platform data from the board file */
 	pdev_data->pdata = wl12xx_get_platform_data();
 	if (IS_ERR(pdev_data->pdata)) {
-		ret = PTR_ERR(pdev_data->pdata);
-		dev_err(glue->dev, "missing wlan platform data: %d\n", ret);
-		goto out_free_glue;
+		dev_info(&func->dev,
+			 "legacy platform data not found, trying device tree\n");
+
+		pdev_data->pdata = wlcore_get_pdata_from_of(&func->dev);
+		if (IS_ERR(pdev_data->pdata)) {
+			ret = PTR_ERR(pdev_data->pdata);
+			dev_err(&func->dev, "can't get platform data\n");
+			goto out_free_glue;
+		}
 	}
 
 	/* if sdio can keep power while host is suspended, enable wow */
@@ -386,16 +435,25 @@ static const struct dev_pm_ops wl1271_sdio_pm_ops = {
 };
 #endif
 
+static const struct of_device_id wlcore_sdio_of_match_table[] = {
+	{ .compatible = "ti,wilink6" },
+	{ .compatible = "ti,wilink7" },
+	{ .compatible = "ti,wilink8" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wlcore_sdio_of_match_table);
+
 static struct sdio_driver wl1271_sdio_driver = {
 	.name		= "wl1271_sdio",
 	.id_table	= wl1271_devices,
 	.probe		= wl1271_probe,
 	.remove		= wl1271_remove,
-#ifdef CONFIG_PM
 	.drv = {
+#ifdef CONFIG_PM
 		.pm = &wl1271_sdio_pm_ops,
-	},
 #endif
+		.of_match_table = of_match_ptr(wlcore_sdio_of_match_table),
+	},
 };
 
 static int __init wl1271_init(void)
diff --git a/net/rfkill/rfkill-gpio.c b/net/rfkill/rfkill-gpio.c
index fb076cd..37a6cbe 100644
--- a/net/rfkill/rfkill-gpio.c
+++ b/net/rfkill/rfkill-gpio.c
@@ -20,6 +20,8 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
 #include <linux/rfkill.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
@@ -39,32 +41,30 @@ enum rfkill_gpio_clk_state {
 #define PWR_CLK_DISABLED(_RF) ((_RF)->pwr_clk_enabled != PWR_ENABLED)
 
 struct rfkill_gpio_data {
-	struct rfkill_gpio_platform_data	*pdata;
 	struct rfkill				*rfkill_dev;
 	char					*reset_name;
 	char					*shutdown_name;
 	enum rfkill_gpio_clk_state		pwr_clk_enabled;
 	struct clk				*pwr_clk;
+	int					gpio_cnt;
+	int					gpiolist[5];
 };
 
 static int rfkill_gpio_set_power(void *data, bool blocked)
 {
 	struct rfkill_gpio_data *rfkill = data;
+	int i;
 
 	if (blocked) {
-		if (gpio_is_valid(rfkill->pdata->shutdown_gpio))
-			gpio_direction_output(rfkill->pdata->shutdown_gpio, 0);
-		if (gpio_is_valid(rfkill->pdata->reset_gpio))
-			gpio_direction_output(rfkill->pdata->reset_gpio, 0);
+		for (i = rfkill->gpio_cnt - 1; i >= 0; i--)
+			gpio_direction_output(rfkill->gpiolist[i], 0);
 		if (rfkill->pwr_clk && PWR_CLK_ENABLED(rfkill))
 			clk_disable(rfkill->pwr_clk);
 	} else {
 		if (rfkill->pwr_clk && PWR_CLK_DISABLED(rfkill))
 			clk_enable(rfkill->pwr_clk);
-		if (gpio_is_valid(rfkill->pdata->reset_gpio))
-			gpio_direction_output(rfkill->pdata->reset_gpio, 1);
-		if (gpio_is_valid(rfkill->pdata->shutdown_gpio))
-			gpio_direction_output(rfkill->pdata->shutdown_gpio, 1);
+		for (i = 0; i < rfkill->gpio_cnt; i++)
+			gpio_direction_output(rfkill->gpiolist[i], 1);
 	}
 
 	if (rfkill->pwr_clk)
@@ -77,16 +77,46 @@ static const struct rfkill_ops rfkill_gpio_ops = {
 	.set_block = rfkill_gpio_set_power,
 };
 
+static struct rfkill_gpio_platform_data *rfkill_gpio_get_pdata_from_of(struct device *dev)
+{
+	struct rfkill_gpio_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+
+	if (!np) {
+		np = of_find_matching_node(NULL, dev->driver->of_match_table);
+		if (!np) {
+			dev_notice(dev, "device tree node not available\n");
+			return ERR_PTR(-ENODEV);
+		}
+	}
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "can't allocate platform data\n");
+		return ERR_PTR(-ENODEV);
+	}
+	pdata->reset_gpio = of_get_named_gpio(np, "gpios", 0);
+	pdata->shutdown_gpio = of_get_named_gpio(np, "gpios", 1);
+	of_property_read_u32(np, "type", &pdata->type);
+	of_property_read_string(np, "name", &pdata->name);
+	return pdata;
+}
+
 static int rfkill_gpio_probe(struct platform_device *pdev)
 {
 	struct rfkill_gpio_data *rfkill;
 	struct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;
+	struct rfkill_gpio_platform_data *p = NULL;
 	int ret = 0;
 	int len = 0;
+	int gpio_cnt = 0;
 
 	if (!pdata) {
-		pr_warn("%s: No platform data specified\n", __func__);
-		return -EINVAL;
+		p = pdata = rfkill_gpio_get_pdata_from_of(&pdev->dev);
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "no platform data\n");
+			return PTR_ERR(p);
+		}
 	}
 
 	/* make sure at-least one of the GPIO is defined and that
@@ -109,8 +139,6 @@ static int rfkill_gpio_probe(struct platform_device *pdev)
 		}
 	}
 
-	rfkill->pdata = pdata;
-
 	len = strlen(pdata->name);
 	rfkill->reset_name = kzalloc(len + 7, GFP_KERNEL);
 	if (!rfkill->reset_name) {
@@ -142,6 +170,7 @@ static int rfkill_gpio_probe(struct platform_device *pdev)
 			pr_warn("%s: failed to get reset gpio.\n", __func__);
 			goto fail_clock;
 		}
+		rfkill->gpiolist[gpio_cnt++] = pdata->reset_gpio;
 	}
 
 	if (gpio_is_valid(pdata->shutdown_gpio)) {
@@ -150,8 +179,9 @@ static int rfkill_gpio_probe(struct platform_device *pdev)
 			pr_warn("%s: failed to get shutdown gpio.\n", __func__);
 			goto fail_reset;
 		}
+		rfkill->gpiolist[gpio_cnt++] = pdata->shutdown_gpio;
 	}
-
+	rfkill->gpio_cnt = gpio_cnt;
 	rfkill->rfkill_dev = rfkill_alloc(pdata->name, &pdev->dev, pdata->type,
 					  &rfkill_gpio_ops, rfkill);
 	if (!rfkill->rfkill_dev) {
@@ -166,7 +196,7 @@ static int rfkill_gpio_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, rfkill);
 
 	dev_info(&pdev->dev, "%s device registered.\n", pdata->name);
-
+	kfree(p);
 	return 0;
 
 fail_rfkill:
@@ -186,7 +216,7 @@ fail_reset_name:
 	kfree(rfkill->reset_name);
 fail_alloc:
 	kfree(rfkill);
-
+	kfree(p);
 	return ret;
 }
 
@@ -194,15 +224,14 @@ static int rfkill_gpio_remove(struct platform_device *pdev)
 {
 	struct rfkill_gpio_data *rfkill = platform_get_drvdata(pdev);
 	struct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;
+	int i;
 
 	if (pdata->gpio_runtime_close)
 		pdata->gpio_runtime_close(pdev);
 	rfkill_unregister(rfkill->rfkill_dev);
 	rfkill_destroy(rfkill->rfkill_dev);
-	if (gpio_is_valid(rfkill->pdata->shutdown_gpio))
-		gpio_free(rfkill->pdata->shutdown_gpio);
-	if (gpio_is_valid(rfkill->pdata->reset_gpio))
-		gpio_free(rfkill->pdata->reset_gpio);
+	for (i = 0; i < rfkill->gpio_cnt; i++)
+		gpio_free(rfkill->gpiolist[i]);
 	if (rfkill->pwr_clk && PWR_CLK_ENABLED(rfkill))
 		clk_disable(rfkill->pwr_clk);
 	if (rfkill->pwr_clk)
@@ -214,12 +243,19 @@ static int rfkill_gpio_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id rfkill_gpio_of_match_table[] = {
+	{ .compatible = "net,rfkill-gpio" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rfkill_gpio_of_match_table);
+
 static struct platform_driver rfkill_gpio_driver = {
 	.probe = rfkill_gpio_probe,
 	.remove = rfkill_gpio_remove,
 	.driver = {
 		   .name = "rfkill_gpio",
 		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rfkill_gpio_of_match_table),
 	},
 };
 
diff --git a/net/rfkill/rfkill-regulator.c b/net/rfkill/rfkill-regulator.c
index d11ac79..d7ea8d2 100644
--- a/net/rfkill/rfkill-regulator.c
+++ b/net/rfkill/rfkill-regulator.c
@@ -14,6 +14,7 @@
 
 #include <linux/module.h>
 #include <linux/err.h>
+#include <linux/of_irq.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
@@ -55,22 +56,50 @@ static struct rfkill_ops rfkill_regulator_ops = {
 	.set_block = rfkill_regulator_set_block,
 };
 
+static struct rfkill_regulator_platform_data *rfkill_regulator_get_pdata_from_of(struct device *dev)
+{
+	struct rfkill_regulator_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+
+	if (!np) {
+		np = of_find_matching_node(NULL, dev->driver->of_match_table);
+		if (!np) {
+			dev_notice(dev, "device tree node not available\n");
+			return ERR_PTR(-ENODEV);
+		}
+	}
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "can't allocate platform data\n");
+		return ERR_PTR(-ENODEV);
+	}
+	of_property_read_u32(np, "type", &pdata->type);
+	of_property_read_string(np, "name", &pdata->name);
+	return pdata;
+}
+
 static int rfkill_regulator_probe(struct platform_device *pdev)
 {
 	struct rfkill_regulator_platform_data *pdata = pdev->dev.platform_data;
+	struct rfkill_regulator_platform_data *p = NULL;
 	struct rfkill_regulator_data *rfkill_data;
 	struct regulator *vcc;
 	struct rfkill *rf_kill;
 	int ret = 0;
 
 	if (pdata == NULL) {
-		dev_err(&pdev->dev, "no platform data\n");
-		return -ENODEV;
+		p = pdata = rfkill_regulator_get_pdata_from_of(&pdev->dev);
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "no platform data\n");
+			return PTR_ERR(p);
+		}
 	}
 
 	if (pdata->name == NULL || pdata->type == 0) {
 		dev_err(&pdev->dev, "invalid name or type in platform data\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
 	}
 
 	vcc = regulator_get_exclusive(&pdev->dev, "vrfkill");
@@ -109,7 +138,7 @@ static int rfkill_regulator_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, rfkill_data);
 	dev_info(&pdev->dev, "%s initialized\n", pdata->name);
-
+	kfree(p);
 	return 0;
 
 err_rfkill_register:
@@ -119,6 +148,7 @@ err_rfkill_alloc:
 err_data_alloc:
 	regulator_put(vcc);
 out:
+	kfree(p);
 	return ret;
 }
 
@@ -135,12 +165,19 @@ static int rfkill_regulator_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id rfkill_regulator_of_match_table[] = {
+	{ .compatible = "net,rfkill-reg" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rfkill_regulator_of_match_table);
+
 static struct platform_driver rfkill_regulator_driver = {
 	.probe = rfkill_regulator_probe,
 	.remove = rfkill_regulator_remove,
 	.driver = {
 		.name = "rfkill-regulator",
 		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(rfkill_regulator_of_match_table),
 	},
 };
 
-- 
1.8.3.1

